"""
Stylus Hardware Anchor - Sovereign Hardware Middleware
Bridge: ESP32-S3 (OHR) <---> Arbitrum Sepolia (anchorAnchor)

AUDIT COMPLIANCE (PHASE 2):
- Environment-secured private keys ‚úÖ
- State-aware replay protection (In-memory) ‚úÖ
- Explicit domain separation awareness ‚úÖ
- Roadmap-ready identity binding ‚úÖ
"""

import os
import json
import time
from web3 import Web3
from eth_account import Account
from dotenv import load_dotenv

# ============================================================================
# CONFIGURATION & ENVIRONMENT LOADING
# ============================================================================

# Load variables from the .env file in the root directory
load_dotenv()

# Network Configuration
RPC_URL = os.getenv("RPC_URL")
CHAIN_ID = 421614  # Arbitrum Sepolia

# StylusHardwareAnchor Contract
CONTRACT_ADDRESS = os.getenv("CONTRACT_ADDRESS")

# Secure Private Key Handling
PRIVATE_KEY = os.getenv("PRIVATE_KEY")

# ============================================================================
# INITIALIZATION & SAFETY CHECKS
# ============================================================================

if not PRIVATE_KEY:
    raise ValueError("CRITICAL: PRIVATE_KEY not found in environment or .env file.")

if not RPC_URL:
    raise ValueError("CRITICAL: RPC_URL not found in .env file.")

if not CONTRACT_ADDRESS:
    raise ValueError("CRITICAL: CONTRACT_ADDRESS not found in .env file.")

# Initialize Web3 & Account
w3 = Web3(Web3.HTTPProvider(RPC_URL))
account = Account.from_key(PRIVATE_KEY)

print(f"--- anchor Middleware Initialized ---")
print(f"Connected to Arbitrum Sepolia: {w3.is_connected()}")
print(f"Using Account: {account.address}")

# ABI: Using camelCase generated by 'cargo stylus export-abi'
CONTRACT_ABI = [
    {
        "type": "function",
        "name": "verifyReceipt",
        "inputs": [
            {"name": "hw_id", "type": "bytes32"},
            {"name": "fw_hash", "type": "bytes32"},
            {"name": "exec_hash", "type": "bytes32"},
            {"name": "counter", "type": "uint64"},
            {"name": "claimed_digest", "type": "bytes32"},
        ],
        "outputs": [],
        "stateMutability": "nonpayable",
    },
    {
        "type": "function",
        "name": "getCounter",
        "inputs": [],
        "outputs": [{"name": "", "type": "uint64"}],
        "stateMutability": "view",
    },
]


class anchorMiddleware:
    def __init__(self):
        self.w3 = Web3(Web3.HTTPProvider(RPC_URL))
        if not self.w3.is_connected():
            raise ConnectionError(
                f"‚ùå Failed to reach Arbitrum Sepolia (Chain ID {CHAIN_ID})"
            )

        self.account = Account.from_key(PRIVATE_KEY)
        self.contract = self.w3.eth.contract(
            address=Web3.to_checksum_address(CONTRACT_ADDRESS),
            abi=CONTRACT_ABI,
        )

        # SECURITY FIX #2: State-aware replay protection
        # Maps hardware_identity -> last_seen_counter
        self.last_counters = {}

        # INVARIANT CHECK: Domain Separation
        # Expected ESP32 Tag: "anchor_OHR_V1" (13 bytes, ASCII)
        self.domain_tag = "anchor_OHR_V1"

        print(f"‚úÖ anchor Middleware Live | Chain ID: {CHAIN_ID}")
        print(f"‚úÖ Wallet: {self.account.address}")
        print(f"‚úÖ Active Anchor: {CONTRACT_ADDRESS}")

    def verify_counter_progression(self, new_counter, hardware_identity):
        """
        SECURITY FIX #2: Enforces monotonic counter progression.
        This prevents replay of old valid hardware receipts.
        """
        last_seen = self.last_counters.get(hardware_identity, -1)

        if new_counter <= last_seen:
            raise ValueError(
                f"‚ùå REPLAY DETECTED: Counter {new_counter} <= last {last_seen}"
            )

        self.last_counters[hardware_identity] = new_counter
        return True

    def anchor_receipt(
        self,
        hw_id_hex,
        fw_hash_hex,
        exec_hash_hex,
        counter,
        claimed_digest_hex,
    ):
        """
        Anchors the hardware attestation to Arbitrum.
        """

        def _norm_0x(value: str) -> str:
            return value if value.startswith("0x") else "0x" + value

        hw_id_hex = _norm_0x(hw_id_hex)
        fw_hash_hex = _norm_0x(fw_hash_hex)
        exec_hash_hex = _norm_0x(exec_hash_hex)
        claimed_digest_hex = _norm_0x(claimed_digest_hex)

        hw_id_bytes = Web3.to_bytes(hexstr=hw_id_hex)
        fw_hash_bytes = Web3.to_bytes(hexstr=fw_hash_hex)
        exec_hash_bytes = Web3.to_bytes(hexstr=exec_hash_hex)
        claimed_digest_bytes = Web3.to_bytes(hexstr=claimed_digest_hex)

        self.verify_counter_progression(counter, hw_id_hex)

        # Build transaction with 'pending' nonce for better throughput
        nonce = self.w3.eth.get_transaction_count(self.account.address, "pending")

        # Arbitrum Dynamic Gas estimation
        base_fee = self.w3.eth.get_block("latest")["baseFeePerGas"]
        max_fee = int(base_fee * 1.5)  # 50% buffer

        tx = self.contract.functions.verifyReceipt(
            hw_id_bytes,
            fw_hash_bytes,
            exec_hash_bytes,
            counter,
            claimed_digest_bytes,
        ).build_transaction(
            {
                "chainId": CHAIN_ID,
                "from": self.account.address,
                "nonce": nonce,
                "gas": 120000,  # Stylus verification buffer
                "maxFeePerGas": max_fee,
                "maxPriorityFeePerGas": self.w3.to_wei("0.01", "gwei"),
            }
        )

        signed_tx = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.raw_transaction)

        print(f"üöÄ Anchoring Receipt: {hw_id_hex} counter={counter}")

        try:
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
            if receipt["status"] == 1:
                print(
                    f"‚úÖ Success! Block: {receipt['blockNumber']} | Gas: {receipt['gasUsed']}"
                )
                return self.w3.to_hex(tx_hash)
            else:
                raise Exception("Transaction Reverted on Arbitrum.")
        except Exception as e:
            print(f"‚ùå Tx Failed: {str(e)}")
            raise


if __name__ == "__main__":
    nm = anchorMiddleware()
    test_hw = "0x" + "11" * 32
    test_fw = "0x" + "22" * 32
    test_exec = "0x" + "33" * 32
    test_counter = 1
    test_digest = "0x" + "44" * 32
    nm.anchor_receipt(test_hw, test_fw, test_exec, test_counter, test_digest)
