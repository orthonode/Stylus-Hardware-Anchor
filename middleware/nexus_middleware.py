"""
Nexus Protocol - Sovereign Hardware Middleware
Bridge: ESP32-S3 (OHR) <---> Arbitrum Sepolia (NexusAnchor)

AUDIT COMPLIANCE (PHASE 2):
- Environment-secured private keys ‚úÖ
- State-aware replay protection (In-memory) ‚úÖ
- Explicit domain separation awareness ‚úÖ
- Roadmap-ready identity binding ‚úÖ
"""

import os
import json
import time
from web3 import Web3
from eth_account import Account
from dotenv import load_dotenv

# ============================================================================
# CONFIGURATION & ENVIRONMENT LOADING
# ============================================================================

# Load variables from the .env file in the root directory
load_dotenv()

# Network Configuration
RPC_URL = os.getenv("RPC_URL")
CHAIN_ID = 421614  # Arbitrum Sepolia

# NexusAnchor Contract (VERIFIED DEPLOYMENT)
CONTRACT_ADDRESS = os.getenv("CONTRACT_ADDRESS", "0xbd4548598e968a4eafd06193bcaa30b8f9b52a76")

# SECURITY FIX: Secure Private Key Handling
# Pulled from .env or environment variable for grant-level security.
PRIVATE_KEY = os.getenv("NEXUS_ANCHOR_KEY")

# ============================================================================
# INITIALIZATION & SAFETY CHECKS
# ============================================================================

if not PRIVATE_KEY:
    raise ValueError("CRITICAL: NEXUS_ANCHOR_KEY not found in environment or .env file.")

if not RPC_URL:
    raise ValueError("CRITICAL: RPC_URL not found in .env file.")

# Initialize Web3 & Account
w3 = Web3(Web3.HTTPProvider(RPC_URL))
account = Account.from_key(PRIVATE_KEY)

print(f"--- Nexus Middleware Initialized ---")
print(f"Connected to Arbitrum Sepolia: {w3.is_connected()}")
print(f"Using Account: {account.address}")

# ABI: Using camelCase generated by 'cargo stylus export-abi'
CONTRACT_ABI = [
    {
        "type": "function",
        "name": "verifyExecution",
        "inputs": [{"name": "receipt_digest", "type": "bytes32"}],
        "outputs": [],
        "stateMutability": "nonpayable"
    },
    {
        "type": "function",
        "name": "getVerifiedCount",
        "inputs": [],
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "view"
    }
]

class NexusMiddleware:
    def __init__(self):
        self.w3 = Web3(Web3.HTTPProvider(RPC_URL))
        if not self.w3.is_connected():
            raise ConnectionError(f"‚ùå Failed to reach Arbitrum Sepolia (Chain ID {CHAIN_ID})")
        
        self.account = Account.from_key(PRIVATE_KEY)
        self.contract = self.w3.eth.contract(
            address=Web3.to_checksum_address(CONTRACT_ADDRESS),
            abi=CONTRACT_ABI
        )

        # SECURITY FIX #2: State-aware replay protection
        # Maps hardware_identity -> last_seen_counter
        self.last_counters = {}
        
        # INVARIANT CHECK: Domain Separation
        # Expected ESP32 Tag: "NEXUS_OHR_V1" (12 bytes, ASCII)
        self.domain_tag = "NEXUS_OHR_V1"

        print(f"‚úÖ Nexus Middleware Live | Chain ID: {CHAIN_ID}")
        print(f"‚úÖ Wallet: {self.account.address}")
        print(f"‚úÖ Active Anchor: {CONTRACT_ADDRESS}")

    def verify_counter_progression(self, new_counter, hardware_identity):
        """
        SECURITY FIX #2: Enforces monotonic counter progression.
        This prevents replay of old valid hardware receipts.
        """
        last_seen = self.last_counters.get(hardware_identity, -1)
        
        if new_counter <= last_seen:
            raise ValueError(f"‚ùå REPLAY DETECTED: Counter {new_counter} <= last {last_seen}")
        
        self.last_counters[hardware_identity] = new_counter
        return True

    def anchor_receipt(self, receipt_digest_hex, hardware_identity_hex=None, counter=None):
        """
        Anchors the hardware attestation to Arbitrum.
        """
        # Normalize digest
        if not receipt_digest_hex.startswith('0x'):
            receipt_digest_hex = '0x' + receipt_digest_hex
        
        digest_bytes = Web3.to_bytes(hexstr=receipt_digest_hex)

        # Enforce Replay Protection if identity is provided
        # TODO (Phase 3): map hardware_identity -> authorized on-chain address
        if hardware_identity_hex and counter is not None:
            self.verify_counter_progression(counter, hardware_identity_hex)

        # Build transaction with 'pending' nonce for better throughput
        nonce = self.w3.eth.get_transaction_count(self.account.address, 'pending')
        
        # Arbitrum Dynamic Gas estimation
        base_fee = self.w3.eth.get_block('latest')['baseFeePerGas']
        max_fee = int(base_fee * 1.5) # 50% buffer
        
        tx = self.contract.functions.verifyExecution(digest_bytes).build_transaction({
            'chainId': CHAIN_ID,
            'from': self.account.address,
            'nonce': nonce,
            'gas': 120000, # Stylus verification buffer
            'maxFeePerGas': max_fee,
            'maxPriorityFeePerGas': self.w3.to_wei('0.01', 'gwei'),
        })

        signed_tx = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        
        print(f"üöÄ Anchoring Digest: {receipt_digest_hex}")
        
        try:
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
            if receipt['status'] == 1:
                print(f"‚úÖ Success! Block: {receipt['blockNumber']} | Gas: {receipt['gasUsed']}")
                return self.w3.to_hex(tx_hash)
            else:
                raise Exception("Transaction Reverted on Arbitrum.")
        except Exception as e:
            print(f"‚ùå Tx Failed: {str(e)}")
            raise

if __name__ == "__main__":
    nm = NexusMiddleware()
    # Test Anchor (Placeholder Digest)
    test_digest = "0x" + "bb" * 32
    nm.anchor_receipt(test_digest, hardware_identity_hex="ESP32-S3-DEVKIT", counter=1)
